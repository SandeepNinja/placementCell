const defaults = {
    fieldSeparator: ",",
    decimalSeparator: ".",
    quoteStrings: true,
    quoteCharacter: '"',
    showTitle: false,
    title: "My Generated Report",
    filename: "generated",
    showColumnHeaders: true,
    useTextFile: false,
    useBom: true,
    columnHeaders: [],
    useKeysAsHeaders: false,
    boolDisplay: { true: "TRUE", false: "FALSE" },
};
const endOfLine = "\r\n";
const byteOrderMark = "\ufeff";
const mkConfig = (opts) => Object.assign({}, defaults, opts);

class CsvGenerationError extends Error {
    constructor(message) {
        super(message);
        this.name = "CsvGenerationError";
    }
}
class EmptyHeadersError extends Error {
    constructor(message) {
        super(message);
        this.name = "EmptyHeadersError";
    }
}
class CsvDownloadEnvironmentError extends Error {
    constructor(message) {
        super(message);
        this.name = "CsvDownloadEnvironmentError";
    }
}

const pack = (value) => value;
const unpack = (newtype) => newtype;
const mkCsvOutput = (pack);
const mkCsvRow = (pack);

const thread = (initialValue, ...fns) => fns.reduce((r, fn) => fn(r), initialValue);
const addBOM = (config) => (output) => config.useBom ? mkCsvOutput(unpack(output) + byteOrderMark) : output;
const addTitle = (config) => (output) => config.showTitle ? mkCsvOutput(unpack(output) + config.title) : output;
const addEndOfLine = (output) => (row) => mkCsvOutput(unpack(output) + unpack(row) + endOfLine);
const buildRow = (config) => (row, data) => addFieldSeparator(config)(mkCsvRow(row + data));
const addFieldSeparator = (config) => (output) => pack(unpack(output) + config.fieldSeparator);
const addHeaders = (config, headers) => (output) => {
    if (!config.showColumnHeaders) {
        return output;
    }
    if (headers.length < 1) {
        throw new EmptyHeadersError("Option to show headers but none supplied. Make sure there are keys in your collection or that you've supplied headers through the config options.");
    }
    let row = mkCsvRow("");
    for (let keyPos = 0; keyPos < headers.length; keyPos++) {
        row = buildRow(config)(row, headers[keyPos]);
    }
    row = mkCsvRow(unpack(row).slice(0, -1));
    return addEndOfLine(output)(row);
};
const addBody = (config, headers, bodyData) => (output) => {
    let body = output;
    for (var i = 0; i < bodyData.length; i++) {
        let row = mkCsvRow("");
        for (let keyPos = 0; keyPos < headers.length; keyPos++) {
            const header = headers[keyPos];
            row = buildRow(config)(row, formatData(config, bodyData[i][header]));
        }
        // Remove trailing comma
        row = mkCsvRow(unpack(row).slice(0, -1));
        body = addEndOfLine(body)(row);
    }
    return body;
};
/**
 *
 * Convert CsvOutput => string for the typechecker.
 *
 * Useful if you need to take the return value and
 * treat is as a string in the rest of your program.
 */
const asString = (unpack);
const isFloat = (input) => +input === input && (!isFinite(input) || Boolean(input % 1));
const formatData = (config, data) => {
    if (config.decimalSeparator === "locale" && isFloat(data)) {
        return data.toLocaleString();
    }
    if (config.decimalSeparator !== "." && isFloat(data)) {
        return data.toString().replace(".", config.decimalSeparator);
    }
    if (typeof data === "string") {
        let val = data;
        if (config.quoteStrings ||
            data.indexOf(config.fieldSeparator) > -1 ||
            data.indexOf("\n") > -1 ||
            data.indexOf("\r") > -1) {
            val = config.quoteCharacter + data + config.quoteCharacter;
        }
        return val;
    }
    if (typeof data === "boolean") {
        // Convert to string to use as lookup in config
        const asStr = data ? "true" : "false";
        // Return the custom boolean display if set
        return config.boolDisplay[asStr];
    }
    return data;
};

/**
 *
 * Generates CsvOutput data from JSON collection using
 * ConfigOptions given.
 *
 * To comfortably use the data as a string around your
 * application, look at {@link asString}.
 *
 * @throws {CsvGenerationError | EmptyHeadersError}
 */
const generateCsv = (config) => (data) => {
    const withDefaults = mkConfig(config);
    const headers = withDefaults.useKeysAsHeaders
        ? Object.keys(data[0])
        : withDefaults.columnHeaders;
    // Build csv output starting with an empty string
    let output = thread(mkCsvOutput(""), addBOM(withDefaults), addTitle(withDefaults), addHeaders(withDefaults, headers), addBody(withDefaults, headers, data));
    if (unpack(output).length < 1) {
        throw new CsvGenerationError("Output is empty. Is your data formatted correctly?");
    }
    return output;
};
/**
 *
 * **Only supported in browser environment.**
 *
 * Will create a hidden anchor link in the page with the
 * download attribute set to a blob version of the CsvOutput data.
 *
 * @throws {CsvDownloadEnvironmentError}
 */
const download = (config) => (csvOutput) => {
    // Downloading is only supported in a browser environment.
    // Node users can simply write the output from generateCsv
    // to disk.
    if (!window) {
        throw new CsvDownloadEnvironmentError("Downloading only supported in a browser environment.");
    }
    const withDefaults = mkConfig(config);
    const data = unpack(csvOutput);
    // Create blob from CsvOutput either as text or csv file.
    const fileType = withDefaults.useTextFile ? "plain" : "csv";
    const fileExtension = withDefaults.useTextFile ? "txt" : "csv";
    let blob = new Blob([data], {
        type: `text/${fileType};charset=utf8;`,
    });
    // Create link element in the browser and set the download
    // attribute to the blob that was created.
    let link = document.createElement("a");
    link.download = `${withDefaults.filename}.${fileExtension}`;
    link.href = URL.createObjectURL(blob);
    // Ensure the link isn't visible to the user or cause layout shifts.
    link.setAttribute("visibility", "hidden");
    // Add to document body, click and remove it.
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

export { asString, download, generateCsv, mkConfig };
//# sourceMappingURL=index.js.map
